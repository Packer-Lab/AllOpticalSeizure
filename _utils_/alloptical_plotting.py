# library of functions that are used for making various plots for all optical photostimulation/imaging experiments
# the data that feeds into these plots are generated by Vape (from alloptical_analysis_photostim.py)

# imports
import os
import numpy as np
import matplotlib as mpl
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
from mpl_point_clicker import clicker
from _utils_.paq_utils import paq_read, frames_discard
from funcsforprajay import funcs as pj
import _alloptical_utils as Utils
import tifffile as tf
from _main_.TwoPhotonImagingMain import TwoPhotonImaging
from _main_.AllOpticalMain import alloptical
from _main_.Post4apMain import Post4ap

from typing import List, Union

from funcsforprajay.wrappers import print_start_end_plot, plot_piping_decorator


# %% plotting utils

def add_scalebar(expobj: TwoPhotonImaging, ax: mpl.axes.Axes, scale_bar_um: float = 100, **kwargs):
    """add scalebar to the image being plotted on the a single matplotlib.axes.Axes object using the TwoPhotonImaging object information.
    Option to specify scale bar um length to add to plot.

    """
    numpx = scale_bar_um/expobj.pix_sz_x

    lw = 5 if 'lw' not in [*kwargs] else kwargs['lw']
    color = 'white' if 'color' not in [*kwargs] else kwargs['color']
    right_offset = 50 if 'right_offset' not in [*kwargs] else kwargs['right_offset']
    bottom_offset = 50 if 'bottom_offset' not in [*kwargs] else kwargs['bottom_offset']

    ax.plot(np.linspace(expobj.frame_x - right_offset - numpx, expobj.frame_x - right_offset, 40), [expobj.frame_y - bottom_offset]*40,
            color=color, lw=lw)
    return ax

# Figure Style settings for notebook.
def image_frame_options():
    mpl.rcParams.update({
        'axes.spines.left': False,
        'axes.spines.bottom': False,
        'axes.spines.top': False,
        'axes.spines.right': False,
        'legend.frameon': False,
        'figure.subplot.wspace': .01,
        'figure.subplot.hspace': .01,
        'ytick.major.left': False,
        'xtick.major.bottom': False
    })

def dataplot_frame_options():
    sns.set()
    sns.set_style('white')

    import matplotlib as mpl
    mpl.rcParams.update({
        'axes.spines.top': False,
        'axes.spines.right': False,
        'legend.fontsize': 'large',
        'axes.labelsize': 'x-large',
        'axes.titlesize': 'x-large',
        'xtick.labelsize': 'large',
        'ytick.labelsize': 'large',
        'legend.frameon': False,
        'figure.subplot.wspace': .01,
        'figure.subplot.hspace': .01,
    })

def heatmap_options():
    jet = mpl.cm.get_cmap('jet')
    jet.set_bad(color='k')


class Klickers:
    "a simple class for attaching multiple mpl_point_clicker.clicker to matplotlib axes"
    def __init__(self, axs: mpl.axes.Axes, classes: List[str]=['class1', 'class2', 'class3'], colors: List[str] = ['blue', 'green', 'purple'],
                 markers=['o', 'x', '*']):

        for i, ax in enumerate(axs):
            setattr(self, f"klicker{i}", clicker(ax=ax, classes=classes, colors=colors, markers=markers))

    def get_all_klickers(self):
        all_attrs = self.__dict__()
        return [all_attrs[attr] for attr in [*all_attrs] if 'klicker' in attr]

    @property
    def total_num(self):
        return len(self.get_all_klickers())


# pair of helpers for multiplotting of frames on axes through a for loop
def multi_plot_subplots(num_total_plots: int, ncols: int=3):
    image_frame_options()
    nrows = int(np.ceil(num_total_plots / ncols)) if int(np.ceil(num_total_plots / ncols)) > 1 else 2
    fig, axs = plt.subplots(nrows=nrows, ncols=ncols, figsize=(ncols * 4, nrows * 4))
    counter = 0
    return fig, axs, counter, ncols, nrows

def get_ax_for_multi_plot(axs, counter, ncols):
    try:
        ax = axs[counter // ncols, counter % ncols]
        counter += 1  # if counter != 0 else 0
        return ax, counter
    except IndexError:
        print('debug here')



# %%
@plot_piping_decorator(figsize=(8,4), nrows=1, ncols=1, verbose=False)
def plot_sz_boundary_location(expobj, fig: mpl.figure.Figure = None, ax: mpl.axes.Axes = None, **kwargs):
    """use for plotting sz boundary location for all stims from a given trial"""

    if len(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == True]) > 1:
        inframe_coord1_x = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == True]['coord1']))[:,0]
        inframe_coord1_y = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == True]['coord1']))[:,1]
        inframe_coord2_x = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == True]['coord2']))[:,0]
        inframe_coord2_y = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == True]['coord2']))[:,1]

        inframe_coord1 = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == True]['coord1']))
        inframe_coord2 = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == True]['coord2']))


        # pj.plot_coordinates(coords=inframe_coord1,frame_x=expobj.frame_x, frame_y=expobj.frame_y, show=False, fig=fig, ax=ax,
        #                     edgecolors='green')
        # pj.plot_coordinates(coords=inframe_coord2,frame_x=expobj.frame_x, frame_y=expobj.frame_y, show=False, fig=fig, ax=ax,
        #                     edgecolors='green')
        ax.plot([inframe_coord1_x, inframe_coord2_x], [inframe_coord1_y, inframe_coord2_y], c='white', linestyle='dashed', alpha=0.3)

    if len(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == False]) > 1:
        outframe_coord1_x = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == False]['coord1']))[:,0]
        outframe_coord1_y = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == False]['coord1']))[:,1]
        outframe_coord2_x = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == False]['coord2']))[:,0]
        outframe_coord2_y = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == False]['coord2']))[:,1]

        outframe_coord1 = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == False]['coord1']))
        outframe_coord2 = np.array(list(expobj.stimsSzLocations[expobj.stimsSzLocations['wavefront_in_frame'] == False]['coord2']))


        # fig, ax = plt.subplots()
        pj.plot_coordinates(coords=outframe_coord1,frame_x=expobj.frame_x, frame_y=expobj.frame_y, show=False, fig=fig, ax=ax,
                            edgecolors='red')
        pj.plot_coordinates(coords=outframe_coord2,frame_x=expobj.frame_x, frame_y=expobj.frame_y, show=False, fig=fig, ax=ax,
                            edgecolors='red')
        ax.plot([outframe_coord1_x, outframe_coord2_x], [outframe_coord1_y, outframe_coord2_y], c='white', linestyle='dashed', alpha=0.3)
        # fig.show()

    plot_SLMtargets_Locs(expobj, fig=fig, ax=ax, show=False)
    title = kwargs['title'] if 'title' in kwargs.keys() else f'{expobj.t_series_name} excluded stims (red coords)'
    ax.set_title(title, wrap=True)

    #
    # for i, stim_frame in enumerate(expobj.stims_in_sz):
    #     # if os.path.exists(expobj.sz_border_path(stim=stim_frame)):
    #     #     xline, yline = pj.xycsv(csvpath=expobj.sz_border_path(stim=stim_frame))
    #     if hasattr(expobj, 'stimsSzLocations'):
    #         if ~np.isnan(expobj.stimsSzLocations.loc[stim_frame, 'sz_num']):
    #             coord1, coord2 = expobj.stimsSzLocations.loc[stim_frame, ['coord1', 'coord2']]
    #             xline = [coord1[0], coord2[0]]
    #             yline = [coord1[1], coord2[1]]
    #
    #
    #             pixels = int(50 / expobj.pix_sz_x)
    #             if expobj.stimsSzLocations[stim_frame, 'wavefront_in_frame']: edgecolors = 'green'
    #             else: edgecolors = 'red'
    #             ax.scatter(x=[xline[0], xline[1]], y=[yline[0], yline[1]], edgecolors=edgecolors)
    #             # pj.plot_coordinates(coords=[(xline[0], yline[0]), (xline[1], yline[1])], frame_x=expobj.frame_x, frame_y=expobj.frame_y,
    #             #                     edgecolors=edgecolors, show=False, fig=fig, ax=ax, title=f'{expobj.t_series_name} excluded stims (red coords)')
    #             ax.plot([xline[0], xline[1]], [yline[0], yline[1]], c='white', linestyle='dashed', alpha=0.3)
    #     print(f"plotting stim # {i}/{len(expobj.stims_in_sz)}", end='\r')

### plot the location of all SLM targets, along with option for plotting the mean img of the current trial
# @print_start_end_plot
@plot_piping_decorator(figsize=(5,5), verbose=False)
def plot_SLMtargets_Locs(expobj, targets_coords: list = None, background: np.ndarray = None, **kwargs):
    """
    plot SLM target coordinate locations

    :param expobj:
    :param targets_coords: ls containing (x,y) coordinates of targets to plot
    :param background:
    :param kwargs:
    :return:
    """

    # image_frame_options()

    fig = kwargs['fig']
    ax = kwargs['ax']

    if background is None:
        background = np.zeros((expobj.frame_x, expobj.frame_y), dtype='uint16')
        ax.imshow(background, cmap='gray')
    else:
        ax.imshow(background, cmap='gray')

    title = kwargs['title'] if 'title' in [*kwargs] else ''

    colors = pj.make_random_color_array(len(expobj.target_coords))
    if targets_coords is None:
        if len(expobj.target_coords) > 1:
            for i in range(len(expobj.target_coords)):
                for (x, y) in expobj.target_coords[i]:
                    ax.scatter(x=x, y=y, edgecolors=colors[i], facecolors=colors[i], linewidths=2.0)
        else:
            if 'edgecolors' in kwargs.keys():
                edgecolors = kwargs['edgecolors']
            else:
                edgecolors = 'yellowgreen'
            for (x, y) in expobj.target_coords_all:
                ax.scatter(x=x, y=y, edgecolors=edgecolors, facecolors=edgecolors, linewidths=2.0)
    elif targets_coords:
        if 'edgecolors' in kwargs.keys():
            edgecolors = kwargs['edgecolors']
        else:
            edgecolors = 'yellowgreen'
        pj.plot_coordinates(coords=targets_coords, frame_x=expobj.frame_x, frame_y=expobj.frame_y, edgecolors=edgecolors, facecolors=edgecolors,
                            background=background, ax=ax, title=title, show=False, fig=fig)

    ax.margins(0)

    ax = add_scalebar(expobj=expobj, ax=ax)

    # fig.tight_layout()
    #
    # if 'title' in kwargs.keys():
    #     if kwargs['title'] is not None:
    #         ax.set_title(kwargs['title'])
    #     else:
    #         pass
    # else:
    #     ax.set_title(f'{expobj.t_series_name} SLM targets location')


# simple plot of the location of the given cell(s) against a black FOV
@print_start_end_plot
@plot_piping_decorator(figsize=(5,5))
def plot_cells_loc(expobj, cells: list, title=None, background: np.array = None, scatter_only: bool = False,
                   show_s2p_targets: bool = True, color_float_list: list = None, cmap: str = 'Reds', invert_y = True, fig=None, ax=None, **kwargs):
    """
    plots an image of the FOV to show the locations of cells given in cells ls.
    :param background: either 2dim numpy array to use as the backsplash or None (where black backsplash will be created)
    :param expobj: alloptical or 2p imaging object
    :param edgecolor: str to specify edgecolor of the scatter plot for cells
    :param cells: ls of cells to plot
    :param title: str title for plot
    :param color_float_list: if given, it will be used to color the cells according a colormap
    :param cmap: cmap to be used in conjuction with the color_float_array argument
    :param show_s2p_targets: if True, then will prioritize coloring of cell points based on whether they were photostim targets
    :param kwargs: optional arguments
            invert_y: if True, invert the reverse the direction of the y axis
            show: if True, show the plot
            fig: a fig plt.subplots() instance, if provided use this fig for making figure
            ax: a ax plt.subplots() instance, if provided use this ax for plotting
    """

    image_frame_options()


    x_list = []
    y_list = []

    facecolors = kwargs['facecolors'] if 'facecolors' in kwargs else 'yellowgreen'
    edgecolors = kwargs['edgecolors'] if 'edgecolors' in kwargs else 'yellowgreen'

    if color_float_list:
        ac = ax.scatter(x=x_list, y=y_list, edgecolors='none', c=color_float_list, linewidths=0.8,
                   cmap=cmap, zorder=1)

        plt.colorbar(ac, ax=ax)
    else:
        for cell in cells:
            y, x = expobj.stat[expobj.cell_id.index(cell)]['med']
            x_list.append(x)
            y_list.append(y)

            if not show_s2p_targets:
                ax.scatter(x=x, y=y, edgecolors=edgecolors, facecolors='none', linewidths=0.8)
            else:
                if hasattr(expobj, 's2p_cell_targets'):
                    if cell in expobj.s2p_cell_targets:
                        facecolors = '#F02A71'
                ax.scatter(x=x, y=y, edgecolors=None, facecolors=facecolors, linewidths=0.8)


    if not scatter_only:
        if background is None:
            black = np.zeros((expobj.frame_x, expobj.frame_y), dtype='uint16')
            ax.imshow(black, cmap='Greys_r', zorder=0)
            ax.set_xlim(0, expobj.frame_x)
            ax.set_ylim(0, expobj.frame_y)
        else:
            ax.imshow(background, cmap='Greys_r', zorder=0)

    if title is not None:
        plt.suptitle(title, wrap=True)

    if 'text' in kwargs.keys():
        if kwargs['text'] is not None:
            ax.text(0.99, 0.95, kwargs['text'],
                    verticalalignment='top', horizontalalignment='right',
                    transform=ax.transAxes, fontweight='bold',
                    color='white', fontsize=10)

    if 'hide_axis_labels' in kwargs.keys():
        ax.set_xticks(ticks=[])
        ax.set_xticklabels([])
        ax.set_yticks(ticks=[])
        ax.set_yticklabels([])


    if 'invert_y' in kwargs.keys():
        if kwargs['invert_y']:
            ax.invert_yaxis()

    ax = add_scalebar(expobj=expobj, ax=ax) if 'scalebar' in [*kwargs] and kwargs['scalebar'] is True else None


# plot to show s2p ROIs location, colored as specified
def s2pRoiImage(expobj, fig_save_name: str = None):
    """
    plot to show the (targets or nontargets) classification of each cell as the actual's filling in the cell's ROI pixels.

    :param expobj: expobj associated with data
    :param df: pandas dataframe (cell_id x stim frames)
    :param clim: color limits
    :param plot_target_coords: bool, if True plot the actual X and Y coords of all photostim cell targets
    :param fig_save_name: where to save the save figure (optional)
    :return:
    """

    image_frame_options()


    fig, ax = plt.subplots(figsize=(5, 5))
    if expobj.frame_x == 512:
        s = 0.003 * (1024/expobj.frame_x * 4)
    else:
        s = 0.003


    ##### targets areas image
    targ_img = np.zeros([expobj.frame_x, expobj.frame_y], dtype='float')
    target_areas_exclude = np.array(expobj.target_areas_exclude)
    targ_img[target_areas_exclude[:, :, 1], target_areas_exclude[:, :, 0]] = 1
    x = np.asarray(list(range(expobj.frame_x)) * expobj.frame_y)
    y = np.asarray([i_y for i_y in range(expobj.frame_y) for i_x in range(expobj.frame_x)])
    img = targ_img.flatten()
    im_array = np.array([x, y], dtype=np.float)
    ax.scatter(im_array[0], im_array[1], c=img, cmap='gray', s=s, zorder=0, alpha=1)

    ##### suite2p ROIs areas image - nontargets
    for n in expobj.s2p_nontargets:
        idx = expobj.cell_id.index(n)
        ypix = expobj.stat[idx]['ypix']
        xpix = expobj.stat[idx]['xpix']
        ax.scatter(xpix, ypix, c='lightsteelblue', s=s, zorder=1, alpha=1)

    ##### suite2p ROIs areas image - exclude cells
    for n in expobj.s2p_cells_exclude:
        idx = expobj.cell_id.index(n)
        ypix = expobj.stat[idx]['ypix']
        xpix = expobj.stat[idx]['xpix']
        ax.scatter(xpix, ypix, c='yellow', s=s, zorder=2, alpha=1)

    ##### suite2p ROIs areas image - targeted cells
    for n in expobj.s2p_cell_targets:
        idx = expobj.cell_id.index(n)
        ypix = expobj.stat[idx]['ypix']
        xpix = expobj.stat[idx]['xpix']
        ax.scatter(xpix, ypix, c='red', s=s, zorder=3, alpha=1)

    ax.set_xlim([0, expobj.frame_x])
    ax.set_ylim([0, expobj.frame_y])

    ax = add_scalebar(expobj=expobj, ax=ax)

    plt.margins(x=0, y=0)
    plt.gca().invert_yaxis()
    # plt.gca().invert_xaxis()
    # fig.show()

    plt.suptitle(f"{expobj.metainfo['animal prep.']} {expobj.metainfo['trial']} - s2p nontargets (blue), exclude (yellow), targets (red); target_areas (white)",
                 y=0.97, fontsize=7)
    plt.show()
    Utils.save_figure(fig, save_path_suffix=f"{fig_save_name}") if fig_save_name else None


### plotting the distribution of radius and aspect ratios - should this be running before the filtering step which is right below????????
def plot_cell_radius_aspectr(expobj, stat, to_plot, min_vline: int = 4, max_vline: int = 12):
    radius = []
    aspect_ratio = []
    for cell in range(len(stat)):
        # if expobj.cell_id[cell] in expobj.good_cells:
        if expobj.cell_id[cell] in expobj.cell_id:
            radius.append(stat[cell]['radius'])
            aspect_ratio.append(stat[cell]['aspect_ratio'])

    if to_plot == 'radius':
        to_plot_ = radius
        plt.axvline(min_vline / expobj.pix_sz_x, color='grey')
        plt.axvline(max_vline / expobj.pix_sz_x, color='grey')
        n, bins, patches = plt.hist(to_plot_, 100)
        title = 'radius - {%s um to %s um}' % (min_vline, max_vline)
    elif to_plot == 'aspect':
        to_plot_ = aspect_ratio
        n, bins, patches = plt.hist(to_plot_, 100)
        title = 'aspect ratio'

    plt.suptitle('All cells - %s' % title, y=0.95)
    plt.show()
    return to_plot_


### plot entire trace of individual targeted cells as super clean subplots, with the same y-axis lims
def plot_photostim_traces(array, expobj, title='', y_min=None, y_max=None, x_label=None,
                          y_label=None, save_fig=None, **kwargs):
    """

    :param array:
    :param expobj:
    :param title:
    :param y_min:
    :param y_max:
    :param x_label:
    :param y_label:
    :param save_fig:
    :param kwargs:
        options include:
            hits: ls; a ls of 1s and 0s that is used to add a scatter point to the plot at stim_start_frames indexes at 1s
    :return:
    """
    # make rolling average for these plots
    w = 30
    array = [(np.convolve(trace, np.ones(w), 'valid') / w) for trace in array]

    len_ = len(array)
    fig, axs = plt.subplots(nrows=len_, sharex=True, figsize=(20, 3 * len_))
    for i in range(len(axs)):
        axs[i].plot(array[i], linewidth=1, color='black', zorder=2)
        if y_min != None:
            axs[i].set_ylim([y_min, y_max])
        for j in expobj.stim_start_frames:
            axs[i].axvline(x=j, c='gray', alpha=0.7, zorder=1)
        if 'scatter' in kwargs.keys():
            x = expobj.stim_start_frames[kwargs['scatter'][i]]
            y = [0] * len(x)
            axs[i].scatter(x, y, c='chocolate', zorder=3)
        if len_ == len(expobj.s2p_cell_targets):
            axs[i].set_title('Cell # %s' % expobj.s2p_cell_targets[i])
        if 'line_ids' in kwargs:
            axs[i].legend(['Target %s' % kwargs['line_ids'][i]], loc='upper left')


    axs[0].set_title((title + ' - %s' % len_ + ' cells'), loc='left', verticalalignment='top', pad=20,
                     fontsize=15)
    axs[0].set_xlabel(x_label)
    axs[0].set_ylabel(y_label)

    if save_fig is not None:
        plt.savefig(save_fig)

    fig.tight_layout(pad=0.2)
    fig.show()


@plot_piping_decorator(figsize=(10,6))
def plot_photostim_traces_overlap(array, expobj, exclude_id=[], y_spacing_factor=1, title='',
                                  x_axis='Time (seconds)', save_fig=None, fig=None, ax=None, **kwargs):
    '''
    :param array:
    :param expobj:
    :param spacing: a multiplication factor that will be used when setting the spacing between each trace in the final plot
    :param title:
    :param y_min:
    :param y_max:
    :param x_label:
    :param save_fig:
    :output: matplotlib plot
    '''
    # make rolling average for these plots
    # w = 30
    # array = np.asarray([(np.convolve(trace, np.ones(w), 'valid') / w) for trace in array])

    len_ = len(array)

    if 'fig' in kwargs.keys():
        fig = kwargs['fig']
        ax = kwargs['ax']
    else:
        if 'figsize' in kwargs.keys():
            fig, ax = plt.subplots(figsize=kwargs['figsize'])
        else:
            fig, ax = plt.subplots(figsize=[20, 10])

    for i in range(len_):
        if i not in exclude_id:
            if 'linewidth' in kwargs.keys():
                linewidth=kwargs['linewidth']
            else:
                linewidth=1
            ax.plot(array[i] + i * 40 * y_spacing_factor, linewidth=linewidth)
    for j in expobj.stim_start_frames:
        if j <= array.shape[1]:
            ax.axvline(x=j, c='gray', alpha=0.3)

    ax.set_xlim([0, expobj.n_frames-3000])

    ax.margins(0)
    # change x axis ticks to seconds
    if 'Time' in x_axis or 'time' in x_axis:
        # change x axis ticks to every 30 seconds
        labels = list(range(0, int(expobj.n_frames // expobj.fps), 30))
        ax.set_xticks(ticks=[(label * expobj.fps) for label in labels])
        ax.set_xticklabels(labels)
        ax.set_xlabel('Time (secs)')

        # labels = [item for item in ax.get_xticks()]
        # for item in labels:
        #     labels[labels.index(item)] = int(round(item / expobj.fps))
        # ax.set_xticklabels(labels)
        # ax.set_xlabel('Time (secs.)')

    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.set_xlabel(x_axis)

    if 'y_lim' in kwargs.keys():
        ax.set_ylim(kwargs['y_lim'])
    else:
        y_max = np.mean(array[-1] + len_ * 40 * y_spacing_factor) + 3 * np.mean(array[-1])
        ax.set_ylim(0, y_max)

    if save_fig is not None:
        plt.savefig(save_fig)

    ax.set_title((title + ' - %s' % len_ + ' cells'), horizontalalignment='center', verticalalignment='top', pad=20,
                 fontsize=10, wrap=True)

    # # finalize plot, set title, and show or return axes
    # if 'fig' in kwargs.keys():
    #     ax.set_title((title + ' - %s' % len_ + ' cells'), horizontalalignment='center', verticalalignment='top', pad=20,
    #                  fontsize=10, wrap=True)
    #     # ax.title.set_text((title + ' - %s' % len_ + ' cells'), wrap=True)
    #     return fig, ax
    # else:
    #     ax.set_title((title + ' - %s' % len_ + ' cells'), horizontalalignment='center', verticalalignment='top', pad=20,
    #                  fontsize=10, wrap=True)
    # if 'show' in kwargs.keys():
    #     if kwargs['show'] is True:
    #         fig.show()
    #     else:
    #         pass
    # else:
    #     fig.show()


### photostim analysis - PLOT avg over photostim. trials traces for the provided traces
@plot_piping_decorator(figsize=(5,5.5))
def plot_periphotostim_avg2(dataset, fps=None, legend_labels=None, colors=None, avg_with_std=False,
                            title='high quality plot', pre_stim_sec=None, ylim=None, fig=None, ax=None, **kwargs):

    meantraces = []
    stdtraces = []

    assert type(dataset) == list, 'provide dataset as list of groups of data'

    if len(dataset) > 1:
        assert len(legend_labels) == len(dataset), print('please provide same number of legend labels as dataset')
        if colors is None: colors = ['black', pj.make_random_color_array(len(dataset) - 1)]
        assert len(colors) == len(legend_labels)
        avg_only = True
        print('-- plotting average +/- std fill for each dataset')
        for i in range(len(dataset)):
            meanst = np.mean(dataset[i], axis=0)
            std = np.std(dataset[i], axis=0, ddof=1)
            meantraces.append(meanst)
            stdtraces.append(std)
            if not meanst.shape == meantraces[i - 1].shape:
                print(f"|--- length mismatch in mean traces of datasets... {title}, shape0 {meanst.shape} and shape1 {meantraces[i - 1].shape}")
            if not std.shape == stdtraces[i - 1].shape:
                print(f"|--- length mismatch in std traces of datasets...{title}, shape0 {std.shape} and shape1 {stdtraces[i - 1].shape}")

        assert len(meantraces[0]) == dataset[0].shape[1], 'length of meantraces is not equal to the dataset provided.'
        assert len(stdtraces[0]) == dataset[0].shape[1], 'length of stdtraces is not equal to the dataset provided.'

    elif len(dataset) == 1:
        meanst = np.mean(dataset[0], axis=0)
        std = np.std(dataset[0], axis=0, ddof=1)
        meantraces.append(meanst)
        stdtraces.append(std)
        # colors = pj.flattenOnce([['black'], pj.make_random_color_array(dataset[0].shape[0])]) if colors is None else colors
        if colors is None: colors = ['black']
        assert len(colors) >= len(dataset)
    else:
        AttributeError('please provide the data to plot in a ls format, each different data group as a ls item...')


    if 'xlabel' not in kwargs or kwargs['xlabel'] is None or 'time' in kwargs['xlabel'] or 'Time' in kwargs['xlabel']:
        ## change xaxis to time (secs)
        if fps is not None:
            if pre_stim_sec is not None:
                x_range = np.linspace(0, len(meantraces[0]) / fps, len(meantraces[0])) - pre_stim_sec  # x scale, but in time domain (transformed from frames based on the provided fps)
                if 'xlabel' in kwargs:
                    ax.set_xlabel(kwargs['xlabel'])
                else:
                    ax.set_xlabel('Time post stim (secs)')
            else:
                AttributeError('need to provide a pre_stim_sec value to the function call!')
        else:
            AttributeError('need to provide fps value to convert xaxis in units of time (secs)')
    else:
        x_range = range(len(meantraces[0]))
        ax.set_xlabel('Frames')

    for i in range(len(meantraces)):
        if avg_with_std:
            if len(meantraces[i]) < len(x_range):  ## TEMP FIX
                mismatch = (len(x_range) - len(meantraces[i]))
                meantraces[i] = np.append(meantraces[i], [0] * mismatch)
                stdtraces[i] = np.append(stdtraces[i], [0] * mismatch)
                print(f'|------ adding {mismatch} zeros to mean and std-fill traces to make the arrays the same length, new length of plot array: {meantraces[i].shape} ')

            ax.plot(x_range, meantraces[i], color=colors[i], lw=2)
            ax.fill_between(x_range, meantraces[i] - stdtraces[i], meantraces[i] + stdtraces[i], alpha=0.15, color=colors[i])
        else:
            ax.plot(x_range, meantraces[i], color=colors[i], lw=2, zorder=5)
            if len(dataset[i]) > 1:
                for idx, trace in enumerate(dataset[i]):
                    ax.plot(x_range, trace, color=colors[idx + 1], alpha=0.3, lw=2, zorder=1)


    if legend_labels:
        if 'fontsize' in kwargs.keys():
            fontsize = kwargs['fontsize']
        else:
            fontsize = 'medium'
        ax.legend(legend_labels, fontsize=fontsize)
    if ylim:
        ax.set_ylim([ylim[0],ylim[1]])
    if 'ylabel' in kwargs.keys():
        ax.set_ylabel(kwargs['ylabel'])
    else:
        pass



    if 'savepath' in kwargs.keys():
        plt.savefig(kwargs['savepath'])

    # # finalize plot, set title, and show or return axes
    # ax.set_title(title)
    # if 'show' in kwargs.keys():
    #     fig.show() if kwargs['show'] else None
    # else:
    #     fig.show()
    #
    # if 'fig' in kwargs.keys():
    #     return fig, ax


### photostim analysis - PLOT avg over all photstim. trials traces from PHOTOSTIM TARGETTED cells
@plot_piping_decorator(figsize=(5,5.5))
def plot_periphotostim_avg(arr=None, pre_stim_sec=1.0, post_stim_sec=3.0, title='', expobj=None,
                           avg_only: bool = False, x_label=None, y_label=None, fig=None, ax=None, pad=20, **kwargs):
    """
    plot trace across all stims
    :param arr: Flu traces to plot (will be plotted as individual traces unless avg_only is True) dimensions should be cells x stims x frames
    :param pre_stim_sec: seconds of array to plot for pre-stim period
    :param post_stim_sec: seconds of array to plot for post-stim period
    :param title: title to use for plot
    :param avg_only: if True, only plot the mean trace calculated from the traces provided in arr
    :param x_label: x axis label
    :param y_label: y axis label
    :param kwargs:
        options include:
            'stim_duration': photostimulation duration in secs
            'y_lims': tuple, y min and max of the plot
            'edgecolor': str, edgecolor of the individual traces behind the mean trace
            'savepath': str, path to save plot to
            'show': bool = to show the plot or not
    :return: ls containing some items about the traces
    """

    fps = expobj.fps  # frames per second rate of the imaging data collection for the data to be plotted
    exp_prestim = expobj.pre_stim  # frames of pre-stim data collected for each trace for this expobj (should be same as what's under expobj.pre_stim_sec)
    if 'stim_duration' in kwargs.keys():
        stim_duration = kwargs['stim_duration']
    else:
        stim_duration = expobj.stim_dur / 1000  # seconds of stimulation duration


    len_ = len(arr)
    flu_avg = np.mean(arr, axis=0)

    # ax.margins(x=0.07)

    if 'alpha' in kwargs.keys():
        alpha = kwargs['alpha']
    else:
        alpha = 0.2

    if x_label is None or not 'Frames' in x_label or 'frames' in x_label:
        # x range in time (secs)
        x_time = np.linspace(0, arr.shape[1] / fps, arr.shape[
            1]) - pre_stim_sec  # x scale, but in time domain (transformed from frames based on the provided fps)
        x = x_time  # set the x plotting range to time
        if x_label is not None:
            x_label = x_label + ' post-stimulation'

        if avg_only is True:
            # ax.axvspan(exp_prestim/fps, (exp_prestim + stim_duration + 1) / fps, alpha=alpha, color='plum', zorder = 3)
            ax.axvspan(0 - pre_stim_sec/fps, 0 + stim_duration + pre_stim_sec / fps, alpha=alpha, color='plum', zorder = 3)  # note that we are setting 0 as the stimulation time
        else:
            ax.axvspan(0 - pre_stim_sec/fps, 0 - pre_stim_sec/fps + stim_duration, alpha=alpha, color='plum', zorder = 3)  # note that we are setting 0 as the stimulation time
    else:
        x = list(range(arr.shape[1]))  # x axis is Frames
        ax.axvspan(exp_prestim, exp_prestim + int(stim_duration*fps), alpha=alpha, color='tomato')

    if not avg_only:
        for cell_trace in arr:
            if 'color' in kwargs.keys():
                ax.plot(x, cell_trace, linewidth=1, alpha=0.6, c=kwargs['color'], zorder=1)
            else:
                if arr.shape[0] > 50:
                    alpha = 0.1
                else:
                    alpha = 0.5
                ax.plot(x, cell_trace, linewidth=1, alpha=alpha, zorder=1)

    ax.plot(x, flu_avg, color='black', linewidth=2.3, zorder=2)  # plot average trace

    if 'y_lims' in kwargs:
        ax.set_ylim(kwargs['y_lims'])
    if pre_stim_sec and post_stim_sec:
        if x_label is None or not 'Frames' in x_label or 'frames' in x_label:
            ax.set_xlim(-pre_stim_sec, stim_duration + post_stim_sec)  # remember that x axis is set to be relative to the stim time (i.e. stim is at t = 0)
        else:
            ax.set_xlim(exp_prestim - int(pre_stim_sec * fps), exp_prestim + int(stim_duration * fps) + int(post_stim_sec * fps) + 1)

    # spine options
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)

    # set axis labels
    ax.set_xlabel(x_label)
    ax.set_ylabel(y_label)

    if 'savepath' in kwargs.keys():
        plt.savefig(kwargs['savepath'])

    if title is not None:
        ax.set_title((title + ' - %s' % len_ + ' traces'), horizontalalignment='center', verticalalignment='top',
                     pad=pad, fontsize=10, wrap=True)

    if avg_only:
        return flu_avg

### photostim analysis - PLOT avg over photostim. trials traces for the provided traces
def plot_periphotostim_addition(dataset, normalize: list = None, fps=None, legend_labels: list = None, colors=None, xlabel='Frames',ylabel='ylabel', avg_with_std=False,
                            title='high quality plot', pre_stim_sec=None, ylim=None, **kwargs):

    if 'fig' in kwargs.keys():
        fig = kwargs['fig']
        ax = kwargs['ax']
    else:
        if 'figsize' in kwargs.keys():
            fig, ax = plt.subplots(figsize=kwargs['figsize'])
        else:
            fig, ax = plt.subplots(figsize=[5, 4])

    if normalize is None:  ## factor to normalize the dataset to be plotted - intended to be used to normalize the summed photostim response by the total # of suite2p ROIs in the experiment's dataset
        normalize = [1] * len(dataset)

    sumtraces_plot = []
    if type(dataset) == list and len(dataset) > 1:
        assert len(legend_labels) == len(dataset), print('please provide same number of legend labels as dataset')
        if colors is None:
            colors = ['black', pj.make_random_color_array(len(dataset) - 1)]
        assert len(colors) == len(legend_labels)
        avg_only = True
        print('-- plotting sum + fill for each dataset')
        for i in range(len(dataset)):
            sum_trace = np.sum(dataset[i], axis=0) / normalize[i]
            sumtraces_plot.append(sum_trace)
            if not sum_trace.shape == sumtraces_plot[i - 1].shape:
                print(f"|--- length mismatch in sum traces of datasets...{title}")

    elif type(dataset) is not list or len(dataset) == 1:
        dataset = list(dataset)
        sum_trace = np.sum(dataset[0], axis=0) / normalize
        std = np.std(dataset[0], axis=0, ddof=1)
        sumtraces_plot.append(sum_trace)
        stdtraces.append(std)
        colors = ['black']
    else:
        AttributeError('please provide the data to plot in a ls format, each different data group as a ls item...')


    if xlabel is None or 'time' in xlabel or 'Time' in xlabel:
        ## change xaxis to time (secs)
        if fps is not None:
            if pre_stim_sec is not None:
                x_range = np.linspace(0, len(sumtraces_plot[0]) / fps, len(
                    sumtraces_plot[0])) - pre_stim_sec  # x scale, but in time domain (transformed from frames based on the provided fps)
                if xlabel is not None:
                    ax.set_xlabel('Time post stim (secs)')
            else:
                AttributeError('need to provide a pre_stim_sec value to the function call!')
        else:
            AttributeError('need to provide fps value to convert xaxis in units of time (secs)')
    else:
        x_range = range(len(sum_trace[0]))

    auc = []
    for i in range(len(sumtraces_plot)):
        if len(sumtraces_plot[i]) < len(x_range):  ## TEMP FIX FOR THE MISMATCH (SEE PRINT STATEMENT BELOW)
            mismatch = (len(x_range) - len(sumtraces_plot[i]))
            sumtraces_plot[i] = np.append(sumtraces_plot[i], [0] * mismatch)
            print(f'|------ adding {mismatch} zeros to sum traces to make the arrays the same length, new length of plot array: {sumtraces_plot[i].shape} ')

        ax.plot(x_range, sumtraces_plot[i], color=colors[i], lw=2)
        ax.fill_between(x_range, 0, sumtraces_plot[i], alpha=0.15, color=colors[i])

        ##### measure area under curve during the poststim response (from pre_stim_sec * fps onwards...)
        period_to_measure = sumtraces_plot[i][int(pre_stim_sec * fps) + 3: int(2 * fps)]  # collect the peristim response that covers the prestim period and the following 3 fr (stim frames)
        auc_ = np.trapz(period_to_measure)
        auc.append(round(auc_, 3))

    if legend_labels:
        if 'fontsize' in kwargs.keys():
            fontsize = kwargs['fontsize']
        else:
            fontsize = 'medium'
        legend_labels_new = []
        for i in range(len(legend_labels)):
            legend_labels_new.append(f"{legend_labels[i]} auc: {auc[i]}")
        ax.legend(legend_labels_new, fontsize=fontsize)
    if ylim:
        ax.set_ylim([ylim[0],ylim[1]])
    ax.set_ylabel(ylabel)
    ax.set_title(title)

    ####
    if 'savepath' in kwargs.keys():
        plt.savefig(kwargs['savepath'])

    # finalize plot, set title, and show or return axes
    if 'show' in kwargs.keys():
        fig.show() if kwargs['show'] else None
    else:
        fig.show()

    if 'fig' in kwargs.keys():
        return fig, ax, auc
    else:
        return auc


def plot_s2p_raw(expobj, cell_id):
    plt.figure(figsize=(50, 3))
    plt.plot(expobj.baseline_raw[expobj.cell_id.index(cell_id)], linewidth=0.5, c='black')
    plt.xlim(0, len(expobj.baseline_raw[0]))
    plt.show()


### (full) plot individual cell's flu or dFF trace, with photostim. timings for that cell
def plot_flu_trace(expobj, cell, x_lims=None, slm_group=None, to_plot='raw', figsize=(20, 3), linewidth=0.10, show=True):
    idx = expobj.cell_id.index(cell)
    raw = expobj.raw[idx]
    raw_ = np.delete(raw, expobj.photostim_frames)  # this is very problematic for the dFF plotting with stim frames if you're deleting ALL of the photostim frames!?!!!
    raw_dff = Utils.normalize_dff(raw_)
    std_dff = np.std(raw_dff, axis=0)
    std = np.std(raw_, axis=0)

    # find locations along time when the trace rises above 2.5std of the mean
    x = []
    # y = []
    for j in np.arange(len(raw_dff), step=4):
        avg = np.mean(raw_dff[j:j + 4])
        if avg > np.mean(raw_dff) + 2 * std_dff:
            x.append(j)
            # y.append(0)

    if to_plot == 'raw':
        to_plot_ = raw
        to_thresh = std
    elif to_plot == 'dff':
        to_plot_ = raw_dff
        to_thresh = std_dff
    else:
        AttributeError('specify to_plot as either "raw" or "dff"')

    # make the plot either as just the raw trace or as a dFF trace with the std threshold line drawn as well.
    plt.figure(figsize=figsize)
    plt.plot(to_plot_, linewidth=linewidth)
    if to_plot == 'raw':
        plt.suptitle(('raw flu for cell #%s' % expobj.cell_id[idx]), horizontalalignment='center',
                     verticalalignment='top',
                     fontsize=15, y=1.00)
    elif to_plot == 'dff':
        plt.scatter(x, y=[0] * len(x), c='r', linewidth=0.1)
        plt.axhline(y=np.mean(to_plot_) + 2.5 * to_thresh, c='green')  # plot threshold line
        plt.suptitle(('dff flu for cell #%s' % expobj.cell_id[idx]), horizontalalignment='center',
                     verticalalignment='top', fontsize=15, y=0.95)

    if slm_group is not None:
        for i in expobj.stim_start_frames[slm_group::expobj.n_groups]:  # select SLM group specific stim trigger frames (may not exist by each individual SLM group though...)
            plt.axvline(x=i - 1, c='gray', alpha=0.1)
    else:
        for i in expobj.stim_start_frames:  # select all stim trigger frames from the trial
            plt.axvline(x=i - 1, c='gray', alpha=0.1)

    if expobj.seizure_frames:
        plt.scatter(expobj.seizure_frames, y=[-20] * len(expobj.seizure_frames), c='g', linewidth=0.10)

    if x_lims:
        plt.xlim(x_lims)

    # plt.ylim(0, 300)
    plt.show() if show else None


# make a plot with the paq file LFP signal to visualize these classifications
@print_start_end_plot
@plot_piping_decorator(figsize=(10,3))
def plot_lfp_stims(expobj: Union[alloptical, Post4ap], title='LFP signal with photostim. shown (in different colors relative to seizure timing)', shrink_text = 1,
                   x_axis: str = 'paq', sz_markings: bool = True, legend = True, fig=None, ax=None, **kwargs):

    print(f"\t \- PLOTTING LFP stims trace ... ")

    # plot LFP signal
    # ax.plot(expobj.lfp_signal, zorder=0, linewidth=0.5)

    lw = 1 if 'linewidth' not in [*kwargs] else kwargs['linewidth']
    color = 'steelblue' if 'color' not in [*kwargs] else kwargs['color']
    fig, ax = plotLfpSignal(expobj=expobj, fig=fig, ax=ax, stim_lines=False, show=False, stim_span_color='', x_axis=x_axis,
                            sz_markings=sz_markings, color=color, downsample=True, linewidth=lw)
    # y_loc = np.percentile(expobj.lfp_signal, 75)
    y_loc = 0 # location of where to place the stim markers on the plot

    s = 100 if 'marker_size' not in [*kwargs] else kwargs['marker_size']

    # collect and plot stim times (with coloring according to sz times if available)
    # note that there is a crop adjustment to the paq-times which is needed to sync up the stim times with the plot being returned from plotLfpSignal (which also on its own crops the LFP signal)
    if 'post' in expobj.metainfo['exptype']:
        assert hasattr(expobj, 'stims_in_sz'), 'no stims in sz list found to plot stim timings in sz.'
        if 'ax2' not in kwargs.keys():
            ax2 = ax.twinx()
        else:
            ax2 = kwargs['ax2']
        if type(expobj.stim_start_frames) != list:
            expobj.stim_start_frames = list(expobj.stim_start_frames)
        x = [(expobj.stim_start_times[expobj.stim_start_frames.index(stim)] - expobj.frame_start_time_actual) for stim in expobj.stims_in_sz]
        x_out = [(expobj.stim_start_times[expobj.stim_start_frames.index(stim)] - expobj.frame_start_time_actual) for stim in expobj.stims_out_sz]
        # if stim not in expobj.stims_bf_sz and stim not in expobj.stims_af_sz]
        x_bf = [(expobj.stim_start_times[expobj.stim_start_frames.index(stim)] - expobj.frame_start_time_actual) for stim in expobj.stims_bf_sz]
        x_af = [(expobj.stim_start_times[expobj.stim_start_frames.index(stim)] - expobj.frame_start_time_actual) for stim in expobj.stims_af_sz]

        ax2.scatter(x=x, y=[y_loc] * len(expobj.stims_in_sz), edgecolors='white', facecolors='violet', marker=11, zorder=3, s=s, linewidths=1.0, label='stims in sz')
        ax2.scatter(x=x_out, y=[y_loc] * len(x_out), edgecolors='white', facecolors='mediumseagreen', marker=11, zorder=3, s=s, linewidths=1.0, label='stims out of sz')
        # ax2.scatter(x=x_bf, y=[y_loc] * len(expobj.stims_bf_sz), edgecolors='white', facecolors='green', marker="^", zorder=3, s=100, linewidths=1.0, label='stims out of sz')
        # ax2.scatter(x=x_af, y=[y_loc] * len(expobj.stims_af_sz), edgecolors='white', facecolors='green', marker="^", zorder=3, s=100, linewidths=1.0, label='stims out of sz')
    else:
        if 'ax2' not in kwargs.keys():
            ax2 = ax.twinx()
        else:
            ax2 = kwargs['ax2']
        if type(expobj.stim_start_frames) != list:
            expobj.stim_start_frames = list(expobj.stim_start_frames)
        x = [(expobj.stim_start_times[expobj.stim_start_frames.index(stim)] - expobj.frame_start_time_actual) for stim in expobj.stim_start_frames]
        ax2.scatter(x=x, y=[y_loc] * len(x), edgecolors='white', facecolors='dimgrey', marker=11, zorder=3, s=s, linewidths=1.0, label='stims')



    # ax2.set_ylim([-0.004, 0.1])
    ax2.set_ylim([-0.1, 0.004])
    ax2.yaxis.set_tick_params(right=False,
                              labelright=False)
    if 'ax2' not in kwargs.keys() and legend == True:
        ax2.legend(loc='lower right')

    if 'ylims' in kwargs and kwargs['ylims'] != None:
        ax.set_ylim(kwargs['ylims'])

    if 'xlims' in kwargs and kwargs['xlims'] != None:
        if 'time' in x_axis or 'Time' in x_axis:
            kwargs['xlims'] = [kwargs['xlims'][0] * expobj.paq_rate, kwargs['xlims'][1] * expobj.paq_rate]
        ax.set_xlim(kwargs['xlims'])

    ax.set_ylabel('LFP - voltage (mV)')

    ax.set_title((expobj.metainfo['animal prep.'] + ' ' + expobj.metainfo['trial'] + ' ' + title), wrap=True)


@print_start_end_plot
@plot_piping_decorator(figsize=(4,10))
def plot_traces_heatmap(expobj, arr, vmin=None, vmax=None, stim_on = None, stim_off= None, figsize=None, title=None, xlims=None, x_label='Frames',
                        cmap='bwr', show=True, cbar: bool = False, fig=None, ax=None, **kwargs):
    """
    plot the whole pre stim to post stim period as a cool heatmap
    :param arr: cells x frames array
    :param vmin: colorbar limit min
    :param vmax: colorbar limit max
    :param stim_on: frame # (relative to frames axis of array)
    :param stim_off: frames # (relative to frames axis of array)
    :param figsize:
    :param title:
    :param xlims:
    :return:
    """
    # if 'fig' in kwargs.keys():
    #     fig = kwargs['fig']
    #     ax = kwargs['ax']
    # else:
    #     if 'figsize' in kwargs.keys():
    #         fig, ax = plt.subplots(figsize=kwargs['figsize'])
    #     else:
    #         fig, ax = plt.subplots(figsize=[5, 5])

    # ax = ax.imshow(arr, aspect='auto', cmap=cmap)
    # # plt.set_cmap(cmap)
    # ax.set_clim(vmin, vmax)

    heatmap_options()

    mesh1 = ax.pcolormesh(arr, cmap=cmap)
    mesh1.set_clim(vmin, vmax)

    if xlims is not None:
        ax.set_xlim(xlims)
    if vmin is not None:
        cbar = fig.colorbar(mesh1, boundaries=np.linspace(vmin, vmax, 1000), ticks=[vmin, 0, vmax])
        if cbar is True:
            pass
        else:
            cbar.remove()
    if stim_on and stim_off:  # draw vertical dashed lines for stim period
        # plt.vlines(x=stim_on, ymin=0, ymax=len(arr), colors='black')
        # plt.vlines(x=stim_off, ymin=0, ymax=len(arr))
        # plt.axvline(x=stim_on, edgecolor='grey', linestyle='--')
        if type(stim_on) is int:
            stim_on = [stim_on]
            stim_off = [stim_off]
        for line in stim_on:
            ax.axvline(x=line, color='black', linestyle='--')
        for line in stim_off:
            ax.axvline(x=line, color='black', linestyle='--')
        ax.set_ylim(0, len(arr)-0.5)

    if 'lfp_signal' in kwargs.keys():
        ax2 = ax.twinx()
        x_c = np.linspace(0, arr.shape[1] - 1, len(kwargs['lfp_signal']))
        # ax2.plot(x_c, kwargs['lfp_signal'] * 50 + arr.shape[0] - 100, c='black')
        ax2.plot(x_c, kwargs['lfp_signal'], c='black')
        ax2.set_ylabel('LFP (mV)')

    if 'Time' in x_label or 'time' in x_label:
        # labels = ls(np.linspace(0, int(arr.shape[1] / expobj.fps), int(arr.shape[1] / expobj.fps * 2 / 2)))
        labels = list(range(0, int(arr.shape[1] / expobj.fps), 5))  # tick label every 5 second
        ax.set_xticks(ticks=[(label * expobj.fps) for label in labels])
        ax.set_xticklabels(labels)
        ax.set_xlabel('Time (secs)')
    else:
        ax.set_xlabel(x_label)

    if title:
        ax.set_title(title, wrap=True)

    if 'y_label' in kwargs.keys():
        ax.set_ylabel(kwargs['y_label'])

    # # finalize plot, set title, and show or return axes
    # if 'fig' in kwargs.keys():
    #     ax.title.set_text(title)
    #     return fig, ax
    # else:
    #     ax.set_title(title, fontsize=10, wrap=True)
    #
    # if 'show' in kwargs.keys():
    #     plt.show() if kwargs['show'] is True else None
    # else:
    #     plt.show()


# plot to show the response magnitude of each cell as the actual's filling in the cell's ROI pixels.
def xyloc_responses(expobj, df, label='response magnitude', clim=[-10, +10], plot_target_coords=True, title='', save_fig: str = None):
    """
    plot to show the response magnitude of each cell as the actual's filling in the cell's ROI pixels.

    :param expobj: expobj associated with data
    :param df: pandas dataframe (cell_id x stim frames)
    :param clim: color limits
    :param plot_target_coords: bool, if True plot the actual X and Y coords of all photostim cell targets
    :param save_fig: where to save the save figure (optional)
    :return:
    """
    # stim_timings = [str(i) for i in
    #                 expobj.stim_start_frames]  # need each stim start frame as a str type for pandas slicing

    # if to_plot == 'dfstdf':
    #     average_responses = expobj.dfstdf_all_cells[stim_timings].mean(axis=1).tolist()
    # elif to_plot == 'dff':
    #     average_responses = expobj.dff_responses_all_cells[stim_timings].mean(axis=1).tolist()
    # else:
    #     raise Exception('need to specify to_plot arg as either dfstdf or dff in string form!')

    cells_ = list(df.index)
    average_responses = df.mean(axis=1).tolist()
    # make a matrix containing pixel locations and responses at each of those pixels
    responses = np.zeros((expobj.frame_x, expobj.frame_x), dtype='uint16')

    for n in cells_:
        idx = expobj.cell_id.index(n)
        ypix = expobj.stat[idx]['ypix']
        xpix = expobj.stat[idx]['xpix']
        responses[ypix, xpix] = 100. + 1 * round(average_responses[cells_.index(n)], 2)

    # mask some 'bad' data, in your case you would have: data < 0.05
    responses = np.ma.masked_where(responses < 0.05, responses)
    cmap = plt.cm.bwr
    cmap.set_bad(color='black')

    plt.figure(figsize=(7, 7))
    im = plt.imshow(responses, cmap=cmap)
    cb = plt.colorbar(im, fraction=0.046, pad=0.04)
    cb.set_label(label)

    plt.clim(100+clim[0], 100+clim[1])
    if plot_target_coords:
        for (x, y) in expobj.target_coords_all:
            plt.scatter(x=x, y=y, edgecolors='green', facecolors='none', linewidths=1.0)
    plt.suptitle(title + ' - SLM targets in green', y=0.90, fontsize=10)
    # pj.plot_cell_loc(expobj, cells=expobj.s2p_cell_targets, background_transparent=True)
    plt.show()
    if save_fig is not None:
        plt.savefig(save_fig)


# plots the raw trace for the Flu mean of the FOV (similar to the ZProject in Fiji)
@print_start_end_plot
@plot_piping_decorator(figsize=(10,3))
def plotMeanRawFluTrace(expobj, stim_span_color='white', stim_lines: bool = True, title='raw Flu trace', x_axis='time', shrink_text=1,
                        fig=None, ax=None, **kwargs):
    """make plot of mean Ca trace averaged over the whole FOV"""

    print(f"\t \- PLOTTING mean raw flu trace ... ")

    # # if there is a fig and ax provided in the function call then use those, otherwise start anew
    # if 'fig' in kwargs.keys():
    #     fig = kwargs['fig']
    #     ax = kwargs['ax']
    # else:
    #     if 'figsize' in kwargs.keys():
    #         fig, ax = plt.subplots(figsize=kwargs['figsize'])
    #     else:
    #         if 'xlims' in kwargs.keys():
    #             fig, ax = plt.subplots(figsize=[10 * (kwargs['xlims'][1] - kwargs['xlims'][0]) / 2000, 3])
    #             fig.tight_layout(pad=0)
    #         else:
    #             fig, ax = plt.subplots(figsize=[10 * len(expobj.meanRawFluTrace) / 2000, 3])
    #             fig.tight_layout(pad=0)

    # change linewidth
    if 'linewidth' in kwargs:
        lw = kwargs['linewidth']
    else:
        lw = 2

    ax.plot(expobj.meanRawFluTrace, c='forestgreen', zorder=1, linewidth=lw)
    ax.margins(0.02)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    # ax.spines['left'].set_visible(False)
    if stim_span_color is not None:
        if hasattr(expobj, 'shutter_frames'):
            for start, end in zip(expobj.shutter_start_frames[0], expobj.shutter_end_frames[0]):
                ax.axvspan(start-9, end + 2, color='white', zorder=2)
                ax.axvspan(start-1, end+1, color='powderblue', zorder=2)
        else:
            for stim in expobj.stim_start_frames:
                ax.axvspan(stim-2, 1 + stim + expobj.stim_duration_frames, color=stim_span_color, zorder=2)
    if stim_lines:
        if stim_span_color is not None:
            for line in expobj.stim_start_frames:
                ax.axvline(x=line, color='black', linestyle='--', linewidth=0.6, zorder=2)
        else:
            for line in expobj.stim_start_frames:
                ax.axvline(x=line, color='black', linestyle='--', linewidth=0.6, zorder=0)
    if 'time' in x_axis or 'Time' in x_axis:
        # change x axis ticks to every 30 seconds
        labels = kwargs['labels'] if 'labels' in [*kwargs] else list(range(0, int(len(expobj.meanRawFluTrace) // expobj.fps), 30))
        labels = [int(i) for i in labels]
        ax.set_xticks(ticks=[(label * expobj.fps) for label in labels])
        ax.set_xticklabels(labels)
        ax.set_xlabel('Time (secs)')
    elif x_axis == 'frames':
        ax.set_xlabel('frame #s')

    if 'show_yticks' in [*kwargs] and kwargs['show_yticks'] == False:
        # change x axis ticks to every 30 seconds
        ax.set_yticks(ticks=[])
        ax.set_yticklabels([])

    ax.set_ylabel('Flu (a.u.)')

    if 'xlims' in kwargs.keys() and kwargs['xlims'] is not None:
        ax.set_xlim(kwargs['xlims'])

    if 'ylims' in kwargs.keys() and kwargs['ylims'] is not None:
        ax.set_ylim(kwargs['ylims'])

    ax.set_title('%s %s %s %s' % (title, expobj.metainfo['exptype'], expobj.metainfo['animal prep.'], expobj.metainfo['trial']))

    return None
    # # add title
    # if not 'fig' in kwargs.keys():
    #     ax.set_title(
    #         '%s %s %s %s' % (title, expobj.metainfo['exptype'], expobj.metainfo['animal prep.'], expobj.metainfo['trial']))
    #
    # if 'show' in kwargs.keys():
    #     plt.show() if kwargs['show'] else None
    # else:
    #     plt.show()
    #
    # if 'fig' in kwargs.keys():
    #     # adding text because adding title doesn't seem to want to work when piping subplots
    #     ax.text(0.98, 0.97, f"Avg. FOV Flu Trace - {expobj.metainfo['exptype']} {expobj.metainfo['animal prep.']} {expobj.metainfo['trial']}",
    #             verticalalignment='top', horizontalalignment='right',
    #             transform=ax.transAxes, fontweight='bold',
    #             color='black', fontsize=10 * shrink_text)
    #     return fig, ax

# plots the raw trace for the Flu mean of the FOV
@print_start_end_plot
@plot_piping_decorator(figsize=(10,3))
def plotLfpSignal(expobj, stim_span_color='powderblue', downsample: bool = True, stim_lines: bool = True, sz_markings: bool = False,
                  title='LFP trace', x_axis='time', hide_xlabel=False, fig=None, ax=None, **kwargs):
    """make plot of LFP with also showing stim locations
    NOTE: ONLY PLOTTING LFP SIGNAL CROPPED TO 2P IMAGING FRAME START AND END TIMES - SO CUTTING OUT THE LFP SIGNAL BEFORE AND AFTER"""

    print(f"\t \- PLOTTING LFP Signal trace ... ")

    # # if there is a fig and ax provided in the function call then use those, otherwise start anew
    # if 'fig' in kwargs.keys():
    #     fig = kwargs['fig']
    #     ax = kwargs['ax']
    # else:
    #     if 'figsize' in kwargs.keys():
    #         fig, ax = plt.subplots(figsize=kwargs['figsize'])
    #     else:
    #         fig, ax = plt.subplots(figsize=[60 * (expobj.stim_start_times[-1] + 1e5 - (expobj.stim_start_times[0] - 1e5)) / 1e7, 3])

    if 'alpha' in kwargs:
        alpha = kwargs['alpha']
    else:
        alpha = 1

    # plot LFP signal
    if 'color' in kwargs:
        color = kwargs['color']
    else:
        color = 'steelblue'

    # option for downsampling of data plot trace
    x = range(len(expobj.lfp_signal[expobj.frame_start_time_actual: expobj.frame_end_time_actual]))
    signal = expobj.lfp_signal[expobj.frame_start_time_actual: expobj.frame_end_time_actual]
    if downsample:
        labels = list(range(0, int(len(signal) / expobj.paq_rate * 1), 15))[::2]  # set x ticks at every 30 secs
        down = 1000
        signal = signal[::down]
        x = x[::down]
        assert len(x) == len(signal), print('something went wrong with the downsampling')

    # change linewidth
    if 'linewidth' in kwargs:
        lw = kwargs['linewidth']
    else:
        lw = 0.4

    ax.plot(x, signal, c=color, zorder=1, linewidth=lw)  ## NOTE: ONLY PLOTTING LFP SIGNAL RELATED TO
    ax.margins(0.02)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    # ax.spines['left'].set_visible(False)


    # plot stims
    if stim_span_color != '':
        for stim in expobj.stim_start_times:
            stim = (stim - expobj.frame_start_time_actual)
            ax.axvspan(stim - 8, 1 + stim + expobj.stim_duration_frames / expobj.fps * expobj.paq_rate, color=stim_span_color, zorder=0, alpha=alpha)
    else:
        if stim_lines:
            for line in expobj.stim_start_times:
                line = (line - expobj.frame_start_time_actual)
                ax.axvline(x=line+2, color='black', linestyle='--', linewidth=0.6, zorder=0)

    # plot seizure onset and offset markings
    if sz_markings:
        if hasattr(expobj, 'seizure_lfp_onsets'):
            for sz_onset in expobj.seizure_lfp_onsets:
                ax.axvline(x=expobj.frame_clock_actual[sz_onset] - expobj.frame_start_time_actual, color='black', linestyle='--', linewidth=1.0, zorder=0)
            for sz_offset in expobj.seizure_lfp_offsets:
                ax.axvline(x=expobj.frame_clock_actual[sz_offset] - expobj.frame_start_time_actual, color='gray', linestyle='--', linewidth=1.0, zorder=0)

    # change x axis ticks to seconds
    labels_ = kwargs['labels'] if 'labels' in [*kwargs] else labels
    labels_ = [int(i) for i in labels_]
    if 'time' in x_axis or 'Time' in x_axis:
        ax.set_xticks(ticks=[(label * expobj.paq_rate) for label in labels_])
        ax.set_xticklabels(labels_)
        ax.tick_params(axis='both', which='both', length=3)
        if not hide_xlabel:
            ax.set_xlabel('Time (secs)')
    # elif 'frame' or "frames" or "Frames" or "Frame" in x_axis:
    #     x_ticks = range(0, expobj.n_frames, 2000)
    #     x_clocks = [x_fr*expobj.paq_rate for x_fr in x_ticks]  ## convert to paq clock dimension
    #     ax.set_xticks(x_clocks)
    #     ax.set_xticklabels(x_ticks)
    #     if not hide_xlabel:
    #         ax.set_xlabel('Frames')
    else:
        ax.set_xlabel('paq clock')
    ax.set_ylabel('Voltage')
    # ax.set_xlim([expobj.frame_start_time_actual, expobj.frame_end_time_actual])  ## this should be limited to the 2p acquisition duration only

    # set ylimits:
    if 'ylims' in kwargs:
        ax.set_ylim(kwargs['ylims'])
    else:
        ax.set_ylim([np.mean(expobj.lfp_signal) - 10, np.mean(expobj.lfp_signal) + 10])

    # set xlimits:
    if 'xlims' in kwargs and kwargs['xlims'] is not None:
        ax.set_xlim(kwargs['xlims'])


    # add title
    ax.set_title(
        '%s - %s %s %s' % (title, expobj.metainfo['exptype'], expobj.metainfo['animal prep.'], expobj.metainfo['trial']))

    # return None
    # if not 'fig' in kwargs.keys():
    #     ax.set_title(
    #         '%s - %s %s %s' % (title, expobj.metainfo['exptype'], expobj.metainfo['animal prep.'], expobj.metainfo['trial']))
    #
    # # options for showing plot or returning plot
    # if 'show' in kwargs.keys():
    #     plt.show() if kwargs['show'] else None
    # else:
    #     plt.show()

    # return fig, ax if 'fig' in kwargs.keys() else None

@print_start_end_plot
@plot_piping_decorator(figsize=(4,5))
def plot_flu_1pstim_avg_trace(expobj, title='Average trace of stims', individual_traces=False, x_axis='time', stim_span_color='white',
                              y_axis: str = 'raw', quantify: bool = False, stims_to_analyze: list = None, write_full_text: bool = True,
                              fig=None, ax=None, **kwargs):

    if 'shrink_text' in kwargs.keys():
        shrink_text = 1 / kwargs['shrink_text']
    else:
        shrink_text = 1

    pre_stim = 1  # seconds
    post_stim = 4  # seconds

    if stims_to_analyze is None:
        stims_to_analyze = expobj.stim_start_frames
    flu_list = [expobj.meanRawFluTrace[stim - int(pre_stim * expobj.fps): stim + int(post_stim * expobj.fps)] for stim in stims_to_analyze]
    # convert to dFF normalized to pre-stim F
    if y_axis == 'dff':  # otherwise default param is raw Flu
        flu_list = [pj.dff(trace, baseline=np.mean(trace[:int(pre_stim * expobj.fps) - 2])) for trace in flu_list]

    avg_flu_trace = np.mean(flu_list, axis=0)
    ax.plot(avg_flu_trace, color='black', zorder=2, linewidth=2.2)
    ax.margins(0)

    if individual_traces:
        # individual traces
        for trace in flu_list:
            ax.plot(trace, color='forestgreen', zorder=1, alpha=0.25)
        if stim_span_color is not None:
            ax.axvspan(int(pre_stim * expobj.fps) - 2.5, int(pre_stim * expobj.fps) + expobj.stim_duration_frames + 2.0, color=stim_span_color, zorder=4)
        elif stim_span_color is None:
            plt.axvline(x=int(pre_stim * expobj.fps) - 2, color='black', linestyle='--', linewidth=1)
            plt.axvline(x=int(pre_stim * expobj.fps) + expobj.stim_duration_frames + 1, color='black', linestyle='--', linewidth=1)
    else:
        # plot standard deviation of the traces array as a span above and below the mean
        std_ = np.std(flu_list, axis=0)
        ax.fill_between(x=range(len(avg_flu_trace)), y1=avg_flu_trace + std_, y2=avg_flu_trace - std_, alpha=0.3, zorder=1, color='forestgreen')
        if stim_span_color is not None:
            ax.axvspan(int(pre_stim * expobj.fps) - 3, int(pre_stim * expobj.fps) + expobj.stim_duration_frames + 1.5, color=stim_span_color, zorder=3)
        elif stim_span_color is None:
            plt.axvline(x=int(pre_stim * expobj.fps) - 2, color='black', linestyle='--', linewidth=1)
            plt.axvline(x=int(pre_stim * expobj.fps) + expobj.stim_duration_frames + 2, color='black', linestyle='--', linewidth=1)

    if x_axis == 'time':
        # change x axis ticks to seconds
        x_ticks_time = [0, 1, 2, 3, 4]
        ax.set_xticks(ticks=[(label * expobj.fps) for label in x_ticks_time])
        ax.set_xticklabels(x_ticks_time)
        ax.set_xlabel('Time (secs)')

    else:
        ax.set_xlabel('frame clock')
    ax.set_ylabel(y_axis)
    ax.set_title(f"{title} {expobj.metainfo['exptype']} {expobj.t_series_name}", fontsize = 7 * shrink_text, wrap=True)


    # quantification of the stim response (compared to prestim baseline)
    if quantify:
        # measure magnitude of response
        response_len = 0.5  # post-stim response period in sec
        poststim_1 = int(pre_stim * expobj.fps) + expobj.stim_duration_frames + 2  # starting just after the end of the shutter opening
        poststim_2 = poststim_1 + int(response_len * expobj.fps)
        baseline = int(pre_stim * expobj.fps) - 2
        ax.axvspan(poststim_1, poststim_2,
                   color='#ffd700', zorder=1, alpha=0.35)
        ax.axvspan(0, baseline,
                   color='#5e5d5d', zorder=1, alpha=0.15)
        response = np.mean(avg_flu_trace[poststim_1:poststim_2]) - np.mean(avg_flu_trace[:baseline])

        # add the response value to the top right of the plot
        ax.text(0.98, 0.97, 'Average response %s: %s' % (y_axis, '{:,.4f}'.format(response)),
                verticalalignment='top', horizontalalignment='right',
                transform=ax.transAxes, fontweight='bold',
                color='green', fontsize=10 * shrink_text)
        if write_full_text:
            ax.text(0.015, 0.97, 'pre-stim',
                    verticalalignment='top', horizontalalignment='left',
                    transform=ax.transAxes, fontweight='bold',
                    color='#5e5d5d', fontsize=10 * shrink_text)
            ax.text(0.265, 0.97, 'post.',
                    verticalalignment='top', horizontalalignment='left',
                    transform=ax.transAxes, fontweight='bold',
                    color='#d1ae00', fontsize=10 * shrink_text)

        # measure the timescale of the decay
        max_value = max(avg_flu_trace[poststim_1:])  # peak Flu value after stim
        threshold = np.exp(-1) * max_value  # set threshod to be at 1/e x peak
        x_ = np.where(avg_flu_trace[poststim_1:] < threshold)[0][0]  # find frame # where, after the stim period, avg_flu_trace reaches the threshold
#         print(x_)
        decay_constant = x_ / expobj.fps  # convert frame # to time
        ax.plot(range(0, int(poststim_1 + x_) + 1), [avg_flu_trace[poststim_1 + x_]] * int(poststim_1 + x_ + 1), color='#ae00ff', linewidth = 3.2, zorder=1)
        ax.text(0.98, 0.90, 'Decay constant (sec): %s' % ('{:,.4f}'.format(decay_constant)),
                verticalalignment='top', horizontalalignment='right',
                transform=ax.transAxes, fontweight='bold',
                color='#ae00ff', fontsize=10 * shrink_text)

    if 'ylims' in kwargs:
        ax.set_ylim([kwargs['ylims'][0], kwargs['ylims'][1]])
    else:
        ax.set_ylim([-0.5, 1.0])

    fig.tight_layout(pad=1.3)

    if quantify:
        return flu_list, round(response, 4), decay_constant


@print_start_end_plot
@plot_piping_decorator(figsize=(4,5))
def plot_lfp_1pstim_avg_trace(expobj, title='Average LFP peri- stims', individual_traces=False, x_axis='time', pre_stim=1.0, post_stim=5.0,
                              optoloopback: bool = False, stims_to_analyze: list = None, shrink_text: int = 1, write_full_text: bool = False,
                              fig=None, ax=None, **kwargs):
    # fig, ax = plt.subplots()
    # if there is a fig and ax provided in the function call then use those, otherwise start anew
    # if 'fig' in kwargs.keys():
    #     fig = kwargs['fig']
    #     ax = kwargs['ax']
    # else:
    #     if 'figsize' in kwargs.keys():
    #         fig, ax = plt.subplots(figsize=kwargs['figsize'])
    #     else:
    #         fig, ax = plt.subplots()

    stim_duration = int(np.mean([expobj.stim_end_times[idx] - expobj.stim_start_times[idx] for idx in range(len(expobj.stim_start_times))]) + 0.01*expobj.paq_rate)
    pre_stim = pre_stim  # seconds
    post_stim = post_stim  # seconds


    if stims_to_analyze is None:
        # stims_to_analyze_paq = expobj.stim_start_times
        stims_to_analyze = expobj.stim_start_frames

    # else:
    # stims_to_analyze_paq = [(expobj.frame_clock_actual[stim] - expobj.frame_start_time_actual) for stim in stims_to_analyze]
    # stims_to_analyze_paq = [expobj.frame_clock_actual[frame] for frame in stims_to_analyze]
    stims_to_analyze_paq = [expobj.stim_start_times[expobj.stim_start_frames.index(stim_frame)] for stim_frame in stims_to_analyze]

    x = [expobj.lfp_signal[stim - int(pre_stim * expobj.paq_rate): stim + int(post_stim * expobj.paq_rate)] for stim in stims_to_analyze_paq]
    x_ = np.mean(x, axis=0)
    ax.plot(x_, color='black', zorder=3, linewidth=1.75)

    if 'ylims' in kwargs.keys() and kwargs['ylims'] is not None:
        ax.set_ylim([kwargs['ylims'][0], kwargs['ylims'][1]])
    else:
        ax.set_ylim([np.mean(x_) - 2.5, np.mean(x_) + 2.5])
    ax.margins(0)

    if individual_traces:
        # individual traces
        for trace in x:
            ax.plot(trace, color='steelblue', zorder=1, alpha=0.25)
            # ax.axvspan(int(pre_stim_sec * expobj.paq_rate),
            #            int(pre_stim_sec * expobj.paq_rate) + stim_duration,
            #            edgecolor='powderblue', zorder=1, alpha=0.3)
        ax.axvspan(int(pre_stim * expobj.paq_rate),
                   int(pre_stim * expobj.paq_rate) + stim_duration,
                   color='skyblue', zorder=1, alpha=0.7)

    else:
        # plot standard deviation of the traces array as a span above and below the mean
        std_ = np.std(x, axis=0)
        ax.fill_between(x=range(len(x_)), y1=x_ + std_, y2=x_ - std_, alpha=0.3, zorder=2, color='steelblue')
        ax.axvspan(int(pre_stim * expobj.paq_rate),
                   int(pre_stim * expobj.paq_rate) + stim_duration, color='skyblue', zorder=1, alpha=0.7)

    if 'shrink_text' in kwargs.keys():
        shrink_text = kwargs['shrink_text']
        print(shrink_text)
    else:
        shrink_text = 0.7
        print(shrink_text)


    if optoloopback:
        ax2 = ax.twinx()
        if not hasattr(expobj, 'opto_loopback'):
            print('loading', expobj.paq_path)

            paq, _ = paq_read(expobj.paq_path, plot=False)
            expobj.paq_rate = paq['rate']

            # find voltage channel and save as lfp_signal attribute
            voltage_idx = paq['chan_names'].index('opto_loopback')
            expobj.opto_loopback = paq['data'][voltage_idx]
            #expobj.save()
        else:
            pass
        x = [expobj.opto_loopback[stim - int(pre_stim * expobj.paq_rate): stim + int(post_stim * expobj.paq_rate)] for stim
             in expobj.stim_start_times]
        y_avg = np.mean(x, axis=0)
        ax2.plot(y_avg, color='royalblue', zorder=3, linewidth=1.75)
        if write_full_text:
            ax2.text(0.98, 0.12, 'Widefield LED TTL',
                     transform=ax.transAxes, fontweight='bold', horizontalalignment='right',
                     color='royalblue', fontsize=10*shrink_text)
        # ax2.set_ylabel('Widefield LED TTL', color='royalblue', fontweight='bold')
        ax2.yaxis.set_tick_params(right=False,
                                  labelright=False)
        ax2.set_ylim([-3, 30])
        ax2.margins(0)



    if x_axis == 'time':
        # change x axis ticks to seconds
        label_format = '{:,.2f}'
        labels = [item for item in ax.get_xticks()]
        for item in labels:
            labels[labels.index(item)] = round(item / expobj.paq_rate, 2)
        ticks_loc = ax.get_xticks().tolist()
        ax.xaxis.set_major_locator(mticker.FixedLocator(ticks_loc))
        ax.set_xticklabels([label_format.format(x) for x in labels])
        ax.set_xlabel('Time (secs)')
    else:
        ax.set_xlabel('paq clock')
    ax.set_ylabel('Voltage')

    # add title
    ax.set_title(
        '%s %s %s %s' % (title, expobj.metainfo['exptype'], expobj.metainfo['animal prep.'], expobj.metainfo['trial']),
    fontsize=10*shrink_text, wrap=True)

    ax.text(0.98, 0.97, '%s %s' % (expobj.metainfo['animal prep.'], expobj.metainfo['trial']),
            verticalalignment='top', horizontalalignment='right',
            transform=ax.transAxes, fontweight='bold',
            color='black', fontsize=10 * shrink_text)

    fig.tight_layout(pad=1.3)



